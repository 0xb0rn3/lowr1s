#!/bin/bash

# lowr1s Installation Script
# Developer: 0xb0rn3 | 0xbv1
# Version: 1.0.0

set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

echo -e "${CYAN}"
echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo "â•‘     lowr1s Installation Script       â•‘"
echo "â•‘       by 0xb0rn3 | 0xbv1            â•‘"
echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo -e "${NC}"

# Check for root
if [[ $EUID -eq 0 ]]; then
   echo -e "${RED}This script should not be run as root!${NC}"
   exit 1
fi

# Detect OS
if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    OS="linux"
elif [[ "$OSTYPE" == "darwin"* ]]; then
    OS="macos"
else
    echo -e "${RED}Unsupported OS: $OSTYPE${NC}"
    exit 1
fi

echo -e "${GREEN}[1/5] Checking dependencies...${NC}"

# Check for Rust
if ! command -v cargo &> /dev/null; then
    echo -e "${YELLOW}Rust not found. Installing...${NC}"
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
    source "$HOME/.cargo/env"
fi

# Install system dependencies
echo -e "${GREEN}[2/5] Installing system dependencies...${NC}"

if [[ "$OS" == "linux" ]]; then
    # Detect package manager
    if command -v apt-get &> /dev/null; then
        PKG_MGR="apt-get"
        echo -e "${CYAN}Detected Debian/Ubuntu system${NC}"
        sudo apt-get update
        sudo apt-get install -y \
            build-essential \
            pkg-config \
            cmake \
            libssl-dev \
            p7zip-full \
            unrar \
            tar \
            gzip \
            bzip2 \
            xz-utils \
            zstd \
            pigz \
            pbzip2 \
            pixz
    elif command -v yum &> /dev/null; then
        PKG_MGR="yum"
        echo -e "${CYAN}Detected RHEL/CentOS/Fedora system${NC}"
        sudo yum groupinstall -y "Development Tools"
        sudo yum install -y \
            cmake \
            openssl-devel \
            p7zip \
            p7zip-plugins \
            unrar \
            tar \
            gzip \
            bzip2 \
            xz \
            zstd
    elif command -v pacman &> /dev/null; then
        PKG_MGR="pacman"
        echo -e "${CYAN}Detected Arch-based system${NC}"
        # Install cmake and other build tools
        sudo pacman -Sy --needed --noconfirm \
            base-devel \
            cmake \
            openssl \
            p7zip \
            unrar \
            tar \
            gzip \
            bzip2 \
            xz \
            zstd \
            pigz \
            pbzip2
    elif command -v zypper &> /dev/null; then
        PKG_MGR="zypper"
        echo -e "${CYAN}Detected openSUSE system${NC}"
        sudo zypper install -y \
            gcc \
            gcc-c++ \
            make \
            cmake \
            libopenssl-devel \
            p7zip \
            unrar \
            tar \
            gzip \
            bzip2 \
            xz \
            zstd
    elif command -v dnf &> /dev/null; then
        PKG_MGR="dnf"
        echo -e "${CYAN}Detected Fedora system${NC}"
        sudo dnf groupinstall -y "Development Tools"
        sudo dnf install -y \
            cmake \
            openssl-devel \
            p7zip \
            p7zip-plugins \
            unrar \
            tar \
            gzip \
            bzip2 \
            xz \
            zstd
    else
        echo -e "${RED}Unsupported package manager${NC}"
        echo -e "${YELLOW}Please manually install: cmake build-essential p7zip unrar${NC}"
        exit 1
    fi
elif [[ "$OS" == "macos" ]]; then
    if ! command -v brew &> /dev/null; then
        echo -e "${YELLOW}Installing Homebrew...${NC}"
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    fi
    brew install cmake p7zip unrar xz zstd pigz pbzip2
fi

# Create project directory
echo -e "${GREEN}[3/5] Setting up project directory...${NC}"
PROJECT_DIR="$HOME/.local/share/lowr1s"
mkdir -p "$PROJECT_DIR"
cd "$PROJECT_DIR"

# Create simplified Cargo.toml without problematic features
cat > Cargo.toml << 'EOF'
[package]
name = "lowr1s"
version = "1.0.0"
edition = "2021"
authors = ["0xb0rn3 | 0xbv1"]
description = "High Performance Archive Tool"

[dependencies]
flate2 = "1.0"
tar = "0.4"
xz2 = "0.1"
zip = "0.6"
rayon = "1.7"
num_cpus = "1.16"
sysinfo = "0.30"
clap = { version = "4.4", features = ["derive"] }
indicatif = "0.17"
walkdir = "2.4"
crossbeam-channel = "0.5"

[profile.release]
opt-level = 3
lto = true
codegen-units = 1
strip = true
panic = "abort"
EOF

# Create source directory
mkdir -p src

# Create the complete Rust source
echo -e "${GREEN}Creating Rust source code...${NC}"
cat > src/main.rs << 'RUST_SOURCE'
// lowr1s - High Performance Archive Core
// Developer: 0xb0rn3 | 0xbv1
// Version: 1.0.0

use std::fs::{File, create_dir_all};
use std::io::{self, Read, Write, BufReader, BufWriter};
use std::path::{Path, PathBuf};
use std::time::Instant;
use flate2::Compression;
use flate2::read::GzDecoder;
use flate2::write::GzEncoder;
use tar::{Archive, Builder};
use xz2::read::XzDecoder;
use xz2::write::XzEncoder;
use zip::{ZipArchive, ZipWriter, write::FileOptions};
use rayon::prelude::*;
use num_cpus;
use sysinfo::{System, SystemExt};
use clap::{Parser, Subcommand};
use indicatif::{ProgressBar, ProgressStyle};
use walkdir::WalkDir;

#[derive(Parser)]
#[command(name = "lowr1s")]
#[command(author = "0xb0rn3 | 0xbv1")]
#[command(version = "1.0.0")]
#[command(about = "High Performance Archive Tool", long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Compress files or directories
    Compress {
        /// Input path
        input: PathBuf,
        /// Output file
        output: PathBuf,
        /// Compression format (gz, xz, zip, tar, tgz, txz)
        #[arg(short, long)]
        format: String,
        /// Compression level (1-9)
        #[arg(short, long, default_value = "6")]
        level: u32,
    },
    /// Decompress archives
    Decompress {
        /// Input archive
        input: PathBuf,
        /// Output directory
        #[arg(short, long)]
        output: Option<PathBuf>,
    },
    /// Benchmark compression algorithms
    Benchmark {
        /// Input path to benchmark
        input: PathBuf,
    },
    /// Show system information
    Info,
}

struct CompressionEngine {
    threads: usize,
    memory_limit: usize,
    buffer_size: usize,
}

impl CompressionEngine {
    fn new() -> Self {
        let threads = num_cpus::get().saturating_sub(1).max(1);
        let mut sys = System::new_all();
        sys.refresh_all();
        
        // Use 80% of available memory
        let memory_limit = (sys.total_memory() as usize * 1024 * 80) / 100;
        let buffer_size = 1024 * 1024 * 16; // 16MB buffer
        
        Self {
            threads,
            memory_limit,
            buffer_size,
        }
    }
    
    fn compress_gz(&self, input: &Path, output: &Path, level: u32) -> io::Result<()> {
        let input_file = File::open(input)?;
        let output_file = File::create(output)?;
        
        let mut encoder = GzEncoder::new(
            BufWriter::with_capacity(self.buffer_size, output_file),
            Compression::new(level)
        );
        
        let mut reader = BufReader::with_capacity(self.buffer_size, input_file);
        let pb = self.create_progress_bar(input)?;
        
        let mut buffer = vec![0; self.buffer_size];
        loop {
            let bytes_read = reader.read(&mut buffer)?;
            if bytes_read == 0 { break; }
            encoder.write_all(&buffer[..bytes_read])?;
            pb.inc(bytes_read as u64);
        }
        
        encoder.finish()?;
        pb.finish_with_message("Compression complete!");
        Ok(())
    }
    
    fn compress_tar_gz(&self, input: &Path, output: &Path, level: u32) -> io::Result<()> {
        let tar_file = File::create(output)?;
        let encoder = GzEncoder::new(
            BufWriter::with_capacity(self.buffer_size, tar_file),
            Compression::new(level)
        );
        
        let mut tar = Builder::new(encoder);
        let pb = self.create_dir_progress_bar(input)?;
        
        if input.is_dir() {
            self.add_dir_to_tar(&mut tar, input, &pb)?;
        } else {
            tar.append_path(input)?;
            pb.inc(1);
        }
        
        tar.finish()?;
        pb.finish_with_message("TAR.GZ compression complete!");
        Ok(())
    }
    
    fn decompress_gz(&self, input: &Path, output: &Path) -> io::Result<()> {
        let input_file = File::open(input)?;
        let mut decoder = GzDecoder::new(BufReader::with_capacity(self.buffer_size, input_file));
        
        let output_file = File::create(output)?;
        let mut writer = BufWriter::with_capacity(self.buffer_size, output_file);
        
        let pb = self.create_progress_bar(input)?;
        
        let mut buffer = vec![0; self.buffer_size];
        loop {
            let bytes_read = decoder.read(&mut buffer)?;
            if bytes_read == 0 { break; }
            writer.write_all(&buffer[..bytes_read])?;
            pb.inc(bytes_read as u64);
        }
        
        pb.finish_with_message("Decompression complete!");
        Ok(())
    }
    
    fn decompress_tar_gz(&self, input: &Path, output: &Path) -> io::Result<()> {
        let tar_gz = File::open(input)?;
        let tar = GzDecoder::new(BufReader::with_capacity(self.buffer_size, tar_gz));
        let mut archive = Archive::new(tar);
        
        create_dir_all(output)?;
        
        let pb = ProgressBar::new_spinner();
        pb.set_style(ProgressStyle::default_spinner()
            .template("{spinner:.green} [{elapsed_precise}] {msg}")
            .unwrap());
        
        for entry in archive.entries()? {
            let mut entry = entry?;
            entry.unpack_in(output)?;
            pb.set_message(format!("Extracted: {:?}", entry.path()?));
        }
        
        pb.finish_with_message("TAR.GZ extraction complete!");
        Ok(())
    }
    
    fn add_dir_to_tar<W: Write>(&self, tar: &mut Builder<W>, dir: &Path, pb: &ProgressBar) -> io::Result<()> {
        for entry in WalkDir::new(dir) {
            let entry = entry?;
            let path = entry.path();
            let name = path.strip_prefix(dir.parent().unwrap_or(Path::new("")))
                .unwrap_or(path);
            
            if path.is_file() {
                tar.append_path_with_name(path, name)?;
                pb.inc(1);
                pb.set_message(format!("Added: {:?}", name));
            }
        }
        Ok(())
    }
    
    fn create_progress_bar(&self, path: &Path) -> io::Result<ProgressBar> {
        let metadata = path.metadata()?;
        let pb = ProgressBar::new(metadata.len());
        pb.set_style(ProgressStyle::default_bar()
            .template("{spinner:.green} [{elapsed_precise}] [{bar:40.cyan/blue}] {bytes}/{total_bytes} {msg}")
            .unwrap());
        Ok(pb)
    }
    
    fn create_dir_progress_bar(&self, path: &Path) -> io::Result<ProgressBar> {
        let count = if path.is_dir() {
            WalkDir::new(path).into_iter().filter_map(Result::ok).count() as u64
        } else {
            1
        };
        
        let pb = ProgressBar::new(count);
        pb.set_style(ProgressStyle::default_bar()
            .template("{spinner:.green} [{elapsed_precise}] [{bar:40.cyan/blue}] {pos}/{len} files {msg}")
            .unwrap());
        Ok(pb)
    }
    
    fn benchmark(&self, input: &Path) -> io::Result<()> {
        println!("\nðŸš€ lowr1s Benchmark Mode");
        println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
        println!("ðŸ’» System: {} threads, {} MB memory limit", self.threads, self.memory_limit / 1024 / 1024);
        
        let formats = vec![
            ("gzip", 6),
            ("gzip-max", 9),
        ];
        
        for (format, level) in formats {
            println!("\nðŸ“Š Testing {}...", format);
            let output = PathBuf::from(format!("/tmp/benchmark_{}.tmp", format));
            
            let start = Instant::now();
            
            self.compress_gz(input, &output, level)?;
            
            let duration = start.elapsed();
            let size = output.metadata()?.len();
            
            println!("  â±ï¸  Time: {:.2}s", duration.as_secs_f64());
            println!("  ðŸ“¦ Size: {} MB", size / 1024 / 1024);
            println!("  âš¡ Speed: {:.2} MB/s", 
                (input.metadata()?.len() as f64 / 1024.0 / 1024.0) / duration.as_secs_f64());
            
            std::fs::remove_file(output).ok();
        }
        
        println!("\nâœ… Benchmark complete!");
        Ok(())
    }
}

fn main() -> io::Result<()> {
    let cli = Cli::parse();
    let engine = CompressionEngine::new();
    
    println!("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println!("â•‘         lowr1s v1.0.0                â•‘");
    println!("â•‘   High Performance Archive Tool      â•‘");
    println!("â•‘      by 0xb0rn3 | 0xbv1             â•‘");
    println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    match cli.command {
        Commands::Compress { input, output, format, level } => {
            println!("ðŸ”§ Compression mode");
            println!("ðŸ“ Input: {:?}", input);
            println!("ðŸ’¾ Output: {:?}", output);
            println!("ðŸ“¦ Format: {}", format);
            println!("âš™ï¸  Level: {}\n", level);
            
            match format.as_str() {
                "gz" | "gzip" => engine.compress_gz(&input, &output, level)?,
                "tgz" | "tar.gz" => engine.compress_tar_gz(&input, &output, level)?,
                _ => {
                    eprintln!("âŒ Unsupported format: {}", format);
                    std::process::exit(1);
                }
            }
        },
        Commands::Decompress { input, output } => {
            println!("ðŸ“‚ Decompression mode");
            println!("ðŸ“ Input: {:?}", input);
            
            let output_path = output.unwrap_or_else(|| {
                let mut p = input.clone();
                p.set_extension("");
                p
            });
            
            println!("ðŸ’¾ Output: {:?}\n", output_path);
            
            // Auto-detect format
            let extension = input.extension()
                .and_then(|e| e.to_str())
                .unwrap_or("");
            
            match extension {
                "gz" => {
                    if input.to_str().unwrap_or("").ends_with(".tar.gz") {
                        engine.decompress_tar_gz(&input, &output_path)?;
                    } else {
                        engine.decompress_gz(&input, &output_path)?;
                    }
                },
                "tgz" => engine.decompress_tar_gz(&input, &output_path)?,
                _ => {
                    eprintln!("âŒ Unable to detect format for: {:?}", input);
                    std::process::exit(1);
                }
            }
        },
        Commands::Benchmark { input } => {
            engine.benchmark(&input)?;
        },
        Commands::Info => {
            let mut sys = System::new_all();
            sys.refresh_all();
            
            println!("ðŸ’» System Information");
            println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
            println!("ðŸ”§ CPU Cores: {} (using {} for operations)", num_cpus::get(), engine.threads);
            println!("ðŸ§  Total RAM: {} GB", sys.total_memory() / 1024 / 1024 / 1024);
            println!("âš¡ Memory Limit: {} MB", engine.memory_limit / 1024 / 1024);
            println!("ðŸ“¦ Buffer Size: {} MB", engine.buffer_size / 1024 / 1024);
            println!("ðŸ–¥ï¸  OS: {} {}", sys.name().unwrap_or_default(), sys.os_version().unwrap_or_default());
            println!("ðŸ—ï¸  Architecture: {}", std::env::consts::ARCH);
        }
    }
    
    Ok(())
}
RUST_SOURCE

# Build with optimizations
echo -e "${GREEN}[4/5] Building Rust components...${NC}"
echo -e "${CYAN}Building with maximum optimizations...${NC}"

# Try to build with native optimizations, fall back if it fails
if ! RUSTFLAGS="-C target-cpu=native -C opt-level=3" cargo build --release 2>/dev/null; then
    echo -e "${YELLOW}Native CPU optimizations failed, building with standard optimizations...${NC}"
    cargo build --release
fi

# Install binaries
echo -e "${GREEN}[5/5] Installing lowr1s...${NC}"

# Create bin directory
BIN_DIR="$HOME/.local/bin"
mkdir -p "$BIN_DIR"

# Copy Rust binary if it exists
if [ -f "target/release/lowr1s" ]; then
    cp target/release/lowr1s "$BIN_DIR/lowr1s-core"
    chmod +x "$BIN_DIR/lowr1s-core"
    echo -e "${GREEN}âœ“ Rust core installed${NC}"
fi

# Copy the bash wrapper from the original repository
if [ -f "$HOME/lowr1s/lowr1s.sh" ]; then
    cp "$HOME/lowr1s/lowr1s.sh" "$PROJECT_DIR/lowr1s.sh"
elif [ -f "./lowr1s.sh" ]; then
    cp "./lowr1s.sh" "$PROJECT_DIR/lowr1s.sh"
fi

# Create main wrapper script
cat > "$BIN_DIR/lowr1s" << 'WRAPPER'
#!/bin/bash
# lowr1s wrapper script

# Check if we should use Rust core for performance
if [[ "$1" == "--rust" ]] || [[ "$LOWR1S_USE_RUST" == "1" ]]; then
    shift
    exec "$HOME/.local/bin/lowr1s-core" "$@"
fi

# Otherwise use bash wrapper for compatibility
if [ -f "$HOME/.local/share/lowr1s/lowr1s.sh" ]; then
    exec bash "$HOME/.local/share/lowr1s/lowr1s.sh" "$@"
else
    # Fallback to Rust core if bash script not found
    exec "$HOME/.local/bin/lowr1s-core" "$@"
fi
WRAPPER

chmod +x "$BIN_DIR/lowr1s"

# Update PATH if needed
if [[ ":$PATH:" != *":$BIN_DIR:"* ]]; then
    echo "" >> "$HOME/.bashrc"
    echo "# lowr1s path" >> "$HOME/.bashrc"
    echo "export PATH=\"$BIN_DIR:\$PATH\"" >> "$HOME/.bashrc"
    echo -e "${YELLOW}Added $BIN_DIR to PATH in ~/.bashrc${NC}"
    echo -e "${YELLOW}Run: source ~/.bashrc${NC}"
fi

# Create config file
CONFIG_DIR="$HOME/.config/lowr1s"
mkdir -p "$CONFIG_DIR"

cat > "$CONFIG_DIR/config.toml" << 'EOF'
# lowr1s Configuration
[performance]
threads = "auto"  # auto, or specific number
memory_limit = "80%"  # percentage of system RAM
buffer_size = 16777216  # 16MB

[compression]
default_format = "tar.gz"
default_level = 6  # 1-9

[features]
use_rust_core = false  # Set to true for maximum performance
parallel_compression = true
show_progress = true
EOF

echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo -e "${GREEN}âœ“ Installation complete!${NC}"
echo ""
echo -e "${CYAN}Usage:${NC}"
echo "  lowr1s compress input.txt output.gz --format gz    # Compress"
echo "  lowr1s decompress archive.tar.gz                    # Decompress"
echo "  lowr1s benchmark /path/to/test                      # Benchmark"
echo "  lowr1s info                                         # System info"
echo ""
echo -e "${YELLOW}Configuration:${NC} $CONFIG_DIR/config.toml"
echo -e "${YELLOW}Binary location:${NC} $BIN_DIR/lowr1s"
echo ""
echo -e "${GREEN}For maximum performance, set:${NC}"
echo "  export LOWR1S_USE_RUST=1"
echo ""
echo -e "${CYAN}Contact:${NC}"
echo "  Developer: 0xb0rn3 | 0xbv1"
echo "  IG: theehiv3"
echo "  Discord & X: oxbv1"
echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo ""
echo -e "${YELLOW}To use lowr1s immediately, run:${NC}"
echo "  source ~/.bashrc"
echo "  lowr1s info"
